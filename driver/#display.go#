package driver

import (
	"fmt"
	"log"
	"sort"
	"sync"

	c "lautenbacher.net/goleds/config"
	hw "lautenbacher.net/goleds/hardware"
	p "lautenbacher.net/goleds/producer"
)

var SEGMENTS map[string][]*ledsegment

type ledsegment struct {
	firstled     int
	lastled      int
	visible      bool
	reverse      bool
	spimultiplex string
	leds         []p.Led
}

func clamp(led int, ledsTotal int) int {
	if led < 0 {
		log.Printf("led index %d is smaller than 0 - using 0", led)
		return 0
	} else if led >= 0 && led <= (ledsTotal-1) {
		return led
	} else {
		log.Printf("led index %d is smaller than max index %d - using max", led, ledsTotal-1)
		return ledsTotal - 1
	}
}

func NewLedSegment(firstled, lastled int, spimultiplex string, reverse bool, visible bool, ledsTotal int) *ledsegment {
	if firstled > lastled {
		log.Printf("First led index %d is bigger than last led index %d - reversing", firstled, lastled)
		tmp := firstled
		firstled = lastled
		lastled = tmp
	}
	if !visible {
		spimultiplex = "__"
	}
	inst := ledsegment{
		firstled:     clamp(firstled, ledsTotal),
		lastled:      clamp(lastled, ledsTotal),
		visible:      visible,
		reverse:      reverse,
		spimultiplex: spimultiplex,
	}
	return &inst
}

func (s *ledsegment) getSegmentLeds() []p.Led {
	if s.visible {
		return s.leds
	} else {
		return nil
	}
}

func (s *ledsegment) setSegmentLeds(sumleds []p.Led) {
	if s.visible {
		s.leds = sumleds[s.firstled : s.lastled+1]
		if s.reverse {
			for i, j := 0, len(s.leds)-1; i < j; i, j = i+1, j-1 {
				s.leds[i], s.leds[j] = s.leds[j], s.leds[i]
			}
		}
	}
}

func InitDisplay(displayConfig c.DisplayConfig, ledsTotal int) {
	SEGMENTS = make(map[string][]*ledsegment)
	for name, segarray := range displayConfig.LedSegments {
		for _, seg := range segarray {
			SEGMENTS[name] = append(SEGMENTS[name], NewLedSegment(seg.FirstLed, seg.LastLed, seg.SpiMultiplex, seg.Reverse, true, ))
		}
	}

	for name, segarray := range SEGMENTS {
		all := make([]bool, displayConfig.LedsTotal)

		for _, seg := range segarray {
			for i := seg.firstled; i <= seg.lastled; i++ {
				if all[i] {
					panic(fmt.Sprintf("Overlapping display segments at index %d", i))
				}
				all[i] = true
			}
		}

		start := -1
		for index, elem := range all {
			if start == -1 && !elem {
				start = index
			} else if start != -1 && elem {
				SEGMENTS[name] = append(SEGMENTS[name], NewLedSegment(start, index-1, "", false, false, displayConfig.LedsTotal))
				start = -1
			}
		}
		if start != -1 {
			SEGMENTS[name] = append(SEGMENTS[name], NewLedSegment(start, len(all)-1, "", false, false, displayConfig.LedsTotal))
		}

		sort.Slice(SEGMENTS[name], func(i, j int) bool { return SEGMENTS[name][i].firstled < SEGMENTS[name][j].firstled })
	}
}

func DisplayDriver(display chan ([]p.Led), sig chan bool, wg *sync.WaitGroup, realHW bool, sensorShow bool) {
	defer wg.Done()
	for {
		select {
		case <-sig:
			log.Println("Ending DisplayDriver go-routine")
			return
		case sumLeds := <-display:
			for _, segarray := range SEGMENTS {
				for _, seg := range segarray {
					seg.setSegmentLeds(sumLeds)
				}
			}
			if !realHW {
				simulateLedDisplay()
			} else {
				for _, segarray := range SEGMENTS {
					for _, seg := range segarray {
						if seg.visible {
							hw.SetLedSegment(seg.spimultiplex, seg.getSegmentLeds())
						}
					}
				}
			}
		}
	}
}
